{"version":3,"file":"index.js","sources":["../src/transform/math/interpolation.ts","../src/transform/system/transfromSystem.ts","../src/toggle/toggleComponent.ts","../src/transform/component/move.ts","../src/transform/component/rotate.ts","../src/transform/component/scale.ts","../src/transform/component/followpath.ts","../src/transform/component/keeprotating.ts","../src/timer/system/timerSystem.ts","../src/timer/component/delay.ts","../src/timer/component/expire.ts","../src/timer/component/interval.ts","../src/helpers/testCube.ts","../src/actionsSequenceSystem/actionsSequenceSystem.ts","../src/triggers/triggerSystem.ts","../src/helpers/helperfunctions.ts","../src/helpers/requests.ts"],"sourcesContent":["export enum InterpolationType {\n  LINEAR,\n  EASEINQUAD,\n  EASEOUTQUAD,\n  EASEQUAD\n}\n\nexport function Interpolate(type: InterpolationType, t: number): number {\n  switch (type) {\n    case InterpolationType.LINEAR:\n      return InterpolateLinear(t)\n    case InterpolationType.EASEINQUAD:\n      return InterpolateEaseInQuad(t)\n    case InterpolationType.EASEOUTQUAD:\n      return InterpolateEaseOutQuad(t)\n    case InterpolationType.EASEQUAD:\n      return InterpolateEaseQuad(t)\n    default:\n      return InterpolateLinear(t)\n  }\n}\nfunction InterpolateLinear(t: number): number {\n  return t\n}\nfunction InterpolateEaseInQuad(t: number): number {\n  return t * t\n}\nfunction InterpolateEaseOutQuad(t: number): number {\n  return t * (2 - t)\n}\nfunction InterpolateEaseQuad(t: number): number {\n  return (t * t) / (2.0 * (t * t - t) + 1.0)\n}\n","import { ITransformComponent } from '../component/itransformcomponent'\n\nexport class TransformSystem implements ISystem {\n  public static _instance: TransformSystem | null = null\n\n  private _components: ComponentConstructor<ITransformComponent>[] = []\n  private _componentGroups: ComponentGroup[] = []\n\n  static createAndAddToEngine(): TransformSystem {\n    if (this._instance == null) {\n      this._instance = new TransformSystem()\n      engine.addSystem(this._instance)\n    }\n    return this._instance\n  }\n\n  static registerCustomComponent<T extends ITransformComponent>(\n    component: ComponentConstructor<T>\n  ) {\n    this.createAndAddToEngine()._components.push(component)\n  }\n\n  public addComponentType(\n    component: ComponentConstructor<ITransformComponent>\n  ) {\n    for (let comp of this._components) {\n      if (component == comp) {\n        return\n      }\n    }\n    this._components.push(component)\n    this._componentGroups.push(engine.getComponentGroup(component, Transform))\n  }\n\n  private constructor() {\n    TransformSystem._instance = this\n  }\n\n  update(dt: number) {\n    for (let i = 0; i < this._components.length; i++) {\n      this.updateComponent(dt, this._components[i], this._componentGroups[i])\n    }\n  }\n\n  private updateComponent<T extends ITransformComponent>(\n    dt: number,\n    component: ComponentConstructor<T>,\n    group: ComponentGroup\n  ) {\n    group.entities.forEach(entity => {\n      const transform = entity.getComponent(Transform)\n      const comp = entity.getComponent(component)\n\n      comp.update(dt)\n      comp.assignValueToTransform(transform)\n      if (comp.hasFinished()) {\n        entity.removeComponent(comp)\n        if (comp.onFinishCallback != null) comp.onFinishCallback()\n      }\n    })\n  }\n}\n","export enum ToggleState {\n  Off = 0,\n  On\n}\n\n/**\n * Toggle component for entities with two states (ON or OFF)\n */\n@Component('toggle')\nexport class ToggleComponent {\n  public enabled: boolean = true\n\n  private onValueChangedCallback?: (value: ToggleState) => void\n  private state: ToggleState = ToggleState.Off\n\n  /**\n   * Create an instance of a ToggleComponent\n   * @param {ToggleState} startingState starting state of the toggle (ON or OFF)\n   * @param {(value: ToggleState) => void} onValueChangedCallback called when toggle state changed\n   */\n  constructor(\n    startingState: ToggleState = ToggleState.On,\n    onValueChangedCallback?: (value: ToggleState) => void\n  ) {\n    this.set(startingState)\n    if (onValueChangedCallback) this.setCallback(onValueChangedCallback)\n  }\n\n  /**\n   * Set trigger to a state\n   * @param {ToggleState} state new state\n   */\n  public set(state: ToggleState): void {\n    this.state = state\n    if (this.onValueChangedCallback) this.onValueChangedCallback(state)\n  }\n\n  /**\n   * Toggle state of ToggleComponent\n   */\n  public toggle(): void {\n    if (this.enabled) {\n      this.set(1 - this.state)\n    }\n  }\n\n  /**\n   * Get if the current toggle state is ON\n   * @return {boolean}\n   */\n  public isOn(): boolean {\n    return this.state == ToggleState.On\n  }\n\n  /**\n   * Set callback for when ToggleComponent state changed\n   * @param {(value: ToggleState) => void} onValueChangedCallback callback\n   */\n  public setCallback(\n    onValueChangedCallback: (value: ToggleState) => void\n  ): void {\n    this.onValueChangedCallback = onValueChangedCallback\n  }\n}\n\nexport default {\n  ToggleComponent,\n  ToggleState\n}\n","import { ITransformComponent } from './itransformcomponent'\nimport { TransformSystem } from '../system/transfromSystem'\nimport { InterpolationType, Interpolate } from '../math/interpolation'\n\n/**\n * Component to translate entity from one position (start) to another (end) in an amount of time\n */\n@Component('moveTransformComponent')\nexport class MoveTransformComponent implements ITransformComponent {\n  private start: ReadOnlyVector3\n  private end: ReadOnlyVector3\n  private speed: number\n  private normalizedTime: number\n  private interpolationType: InterpolationType\n  private lerpTime: number\n\n  onFinishCallback?: () => void\n\n  /**\n   * Create a MoveTransformComponent instance to add as a component to a Entity\n   * @param {ReadOnlyVector3} start starting position\n   * @param {ReadOnlyVector3} end ending position\n   * @param {number} duration duration (in seconds) of start to end translation\n   * @param {()=>void} onFinishCallback called when translation ends\n   * @param {InterpolationType} interpolationType type of interpolation to be used (default: LINEAR)\n   */\n  constructor(\n    start: ReadOnlyVector3,\n    end: ReadOnlyVector3,\n    duration: number,\n    onFinishCallback?: () => void,\n    interpolationType: InterpolationType = InterpolationType.LINEAR\n  ) {\n    this.start = start\n    this.end = end\n    this.normalizedTime = 0\n    this.lerpTime = 0\n    this.onFinishCallback = onFinishCallback\n    this.interpolationType = interpolationType\n\n    if (duration != 0) {\n      this.speed = 1 / duration\n    } else {\n      this.speed = 0\n      this.normalizedTime = 1\n      this.lerpTime = 1\n    }\n\n    let instance = TransformSystem.createAndAddToEngine()\n    instance.addComponentType(MoveTransformComponent)\n  }\n\n  update(dt: number) {\n    this.normalizedTime = Scalar.Clamp(\n      this.normalizedTime + dt * this.speed,\n      0,\n      1\n    )\n    this.lerpTime = Interpolate(this.interpolationType, this.normalizedTime)\n  }\n\n  hasFinished(): boolean {\n    return this.normalizedTime >= 1\n  }\n\n  assignValueToTransform(transform: Transform) {\n    transform.position = Vector3.Lerp(this.start, this.end, this.lerpTime)\n  }\n}\n","import { ITransformComponent } from './itransformcomponent'\nimport { TransformSystem } from '../system/transfromSystem'\nimport { InterpolationType, Interpolate } from '../math/interpolation'\n\n/**\n * Component to rotate entity from one rotation (start) to another (end) in an amount of time\n */\n@Component('rotateTransformComponent')\nexport class RotateTransformComponent implements ITransformComponent {\n  private start: ReadOnlyQuaternion\n  private end: ReadOnlyQuaternion\n  private speed: number\n  private normalizedTime: number\n  private interpolationType: InterpolationType\n  private lerpTime: number\n\n  onFinishCallback?: () => void\n\n  /**\n   * Create a RotateTransformComponent instance to add as a component to a Entity\n   * @param {ReadOnlyQuaternion} start starting rotation\n   * @param {ReadOnlyQuaternion} end ending rotation\n   * @param {number} duration duration (in seconds) of start to end rotation\n   * @param {() => void} onFinishCallback called when rotation ends\n   * @param {InterpolationType} interpolationType type of interpolation to be used (default: LINEAR)\n   */\n  constructor(\n    start: ReadOnlyQuaternion,\n    end: ReadOnlyQuaternion,\n    duration: number,\n    onFinishCallback?: () => void,\n    interpolationType: InterpolationType = InterpolationType.LINEAR\n  ) {\n    this.start = start\n    this.end = end\n    this.normalizedTime = 0\n    this.lerpTime = 0\n    this.onFinishCallback = onFinishCallback\n    this.interpolationType = interpolationType\n\n    if (duration != 0) {\n      this.speed = 1 / duration\n    } else {\n      this.speed = 0\n      this.normalizedTime = 1\n      this.lerpTime = 1\n    }\n\n    let instance = TransformSystem.createAndAddToEngine()\n    instance.addComponentType(RotateTransformComponent)\n  }\n\n  update(dt: number) {\n    this.normalizedTime = Scalar.Clamp(\n      this.normalizedTime + dt * this.speed,\n      0,\n      1\n    )\n    this.lerpTime = Interpolate(this.interpolationType, this.normalizedTime)\n  }\n\n  hasFinished(): boolean {\n    return this.normalizedTime >= 1\n  }\n\n  assignValueToTransform(transform: Transform) {\n    transform.rotation = Quaternion.Slerp(this.start, this.end, this.lerpTime)\n  }\n}\n","import { ITransformComponent } from './itransformcomponent'\nimport { TransformSystem } from '../system/transfromSystem'\nimport { InterpolationType, Interpolate } from '../math/interpolation'\n\n/**\n * Component to scale entity from one value (start) to another (end) in an amount of time\n */\n@Component('scaleTransformComponent')\nexport class ScaleTransformComponent implements ITransformComponent {\n  private start: ReadOnlyVector3\n  private end: ReadOnlyVector3\n  private speed: number\n  private normalizedTime: number\n  private interpolationType: InterpolationType\n  private lerpTime: number\n\n  onFinishCallback?: () => void\n\n  /**\n   * Create a ScaleTransformComponent instance to add as a component to a Entity\n   * @param {ReadOnlyVector3} start starting scale\n   * @param {ReadOnlyVector3} end ending scale\n   * @param {number} duration duration (in seconds) of start to end scaling\n   * @param {() => void} onFinishCallback called when scaling ends\n   * @param {InterpolationType} interpolationType type of interpolation to be used (default: LINEAR)\n   */\n  constructor(\n    start: ReadOnlyVector3,\n    end: ReadOnlyVector3,\n    duration: number,\n    onFinishCallback?: () => void,\n    interpolationType: InterpolationType = InterpolationType.LINEAR\n  ) {\n    this.start = start\n    this.end = end\n    this.normalizedTime = 0\n    this.lerpTime = 0\n    this.onFinishCallback = onFinishCallback\n    this.interpolationType = interpolationType\n\n    if (duration != 0) {\n      this.speed = 1 / duration\n    } else {\n      this.speed = 0\n      this.normalizedTime = 1\n      this.lerpTime = 1\n    }\n\n    let instance = TransformSystem.createAndAddToEngine()\n    instance.addComponentType(ScaleTransformComponent)\n  }\n\n  update(dt: number) {\n    this.normalizedTime = Scalar.Clamp(\n      this.normalizedTime + dt * this.speed,\n      0,\n      1\n    )\n    this.lerpTime = Interpolate(this.interpolationType, this.normalizedTime)\n  }\n\n  hasFinished(): boolean {\n    return this.normalizedTime >= 1\n  }\n\n  assignValueToTransform(transform: Transform) {\n    transform.scale = Vector3.Lerp(this.start, this.end, this.lerpTime)\n  }\n}\n","import { ITransformComponent } from './itransformcomponent'\nimport { TransformSystem } from '../system/transfromSystem'\n\n/**\n * Component to move an entity down a fixed path in a given amount of time\n */\n@Component('followPathComponent')\nexport class FollowPathComponent implements ITransformComponent {\n  private points: Vector3[]\n  private speed: number[] = []\n  private normalizedTime: number\n  private currentIndex: number\n\n  onFinishCallback?: () => void\n  onPointReachedCallback?: (currentPoint: Vector3, nextPoint: Vector3) => void\n\n  /**\n   * Create a FollowPathComponent instance to add as a component to a Entity\n   * @param {Vector3[]} points array of points for the path\n   * @param {number} duration duration of the movement through the path\n   * @param {() => void} onFinishCallback called when movement ends\n   * @param {(currentPoint: Vector3, nextPoint: Vector3) => void} onPointReachedCallback called everytime an entity reaches a point of the path\n   */\n  constructor(\n    points: Vector3[],\n    duration: number,\n    onFinishCallback?: () => void,\n    onPointReachedCallback?: (currentPoint: Vector3, nextPoint: Vector3) => void\n  ) {\n    this.normalizedTime = 0\n    this.currentIndex = 0\n    this.points = points\n    this.onFinishCallback = onFinishCallback\n    this.onPointReachedCallback = onPointReachedCallback\n\n    if (points.length < 2) {\n      throw new Error('At least 2 points are needed for FollowPathComponent.')\n    }\n\n    if (duration > 0) {\n      let totalDist = 0\n      let pointsDist = []\n      for (let i = 0; i < points.length - 1; i++) {\n        let sqDist = Vector3.Distance(points[i], points[i + 1])\n        totalDist += sqDist\n        pointsDist.push(sqDist)\n      }\n      for (let i = 0; i < pointsDist.length; i++) {\n        this.speed.push(1 / ((pointsDist[i] / totalDist) * duration))\n      }\n    } else {\n      this.normalizedTime = 1\n      this.currentIndex = points.length - 2\n    }\n\n    let instance = TransformSystem.createAndAddToEngine()\n    instance.addComponentType(FollowPathComponent)\n  }\n\n  update(dt: number) {\n    this.normalizedTime = Scalar.Clamp(\n      this.normalizedTime + dt * this.speed[this.currentIndex],\n      0,\n      1\n    )\n    if (\n      this.normalizedTime >= 1 &&\n      this.currentIndex < this.points.length - 2\n    ) {\n      this.currentIndex++\n      this.normalizedTime = 0\n      if (\n        this.onPointReachedCallback &&\n        this.currentIndex < this.points.length - 1\n      )\n        this.onPointReachedCallback(\n          this.points[this.currentIndex],\n          this.points[this.currentIndex + 1]\n        )\n    }\n  }\n\n  hasFinished(): boolean {\n    return (\n      this.currentIndex >= this.points.length - 2 && this.normalizedTime >= 1\n    )\n  }\n\n  assignValueToTransform(transform: Transform) {\n    transform.position = Vector3.Lerp(\n      this.points[this.currentIndex],\n      this.points[this.currentIndex + 1],\n      this.normalizedTime\n    )\n  }\n}\n\n/**\n * Component to move a entity down a fixed path in an amount of time\n */\n@Component('followCurvedPathComponent')\nexport class FollowCurvedPathComponent implements ITransformComponent {\n  private points: Vector3[]\n  private speed: number[] = []\n  private normalizedTime: number\n  private currentIndex: number\n  private turnToFaceNext: boolean = false\n  private facingNext: boolean = false\n\n  onFinishCallback?: () => void\n\n  /**\n   * Create a FollowCurvedPathComponent instance to add as a component to a Entity\n   * @param {Vector3[]} points array of points that the curve must pass through\n   * @param {number} duration duration of the movement through the path\n   * @param {number} numberOfSegments how many straight line segments to use to construct the curve\n   * @param {boolean} turnToFaceNext if true, rotates for each segment to always look forward\n   * @param {boolean} closedCircle if true, traces a circle that starts back at the beginning, keeping the curvature rounded in the seams too\n   * @param {() => void} onFinishCallback called when movement ends\n   */\n  constructor(\n    points: Vector3[],\n    duration: number,\n    numberOfSegments: number,\n    turnToFaceNext?: boolean,\n    closedCircle?: boolean,\n    onFinishCallback?: () => void\n  ) {\n    this.normalizedTime = 0\n    this.currentIndex = 0\n    this.points = Curve3.CreateCatmullRomSpline(\n      points,\n      numberOfSegments,\n      closedCircle ? true : false\n    ).getPoints()\n    this.onFinishCallback = onFinishCallback\n    this.turnToFaceNext = turnToFaceNext ? turnToFaceNext : false\n\n    if (this.points.length < 2) {\n      throw new Error('At least 2 points are needed for FollowPathComponent.')\n    }\n\n    if (duration > 0) {\n      let totalDist = 0\n      let pointsDist = []\n      for (let i = 0; i < this.points.length - 1; i++) {\n        let sqDist = Vector3.Distance(this.points[i], this.points[i + 1])\n        totalDist += sqDist\n        pointsDist.push(sqDist)\n      }\n      for (let i = 0; i < pointsDist.length; i++) {\n        this.speed.push(1 / ((pointsDist[i] / totalDist) * duration))\n      }\n    } else {\n      this.normalizedTime = 1\n      this.currentIndex = points.length - 2\n    }\n\n    let instance = TransformSystem.createAndAddToEngine()\n    instance.addComponentType(FollowCurvedPathComponent)\n  }\n\n  update(dt: number) {\n    this.normalizedTime = Scalar.Clamp(\n      this.normalizedTime + dt * this.speed[this.currentIndex],\n      0,\n      1\n    )\n    if (\n      this.normalizedTime >= 1 &&\n      this.currentIndex < this.points.length - 2\n    ) {\n      this.currentIndex++\n      this.normalizedTime = 0\n      if (this.turnToFaceNext == true) {\n        this.facingNext = false\n      }\n    }\n  }\n\n  hasFinished(): boolean {\n    return (\n      this.currentIndex >= this.points.length - 2 && this.normalizedTime >= 1\n    )\n  }\n\n  assignValueToTransform(transform: Transform) {\n    transform.position = Vector3.Lerp(\n      this.points[this.currentIndex],\n      this.points[this.currentIndex + 1],\n      this.normalizedTime\n    )\n\n    if (!this.facingNext) {\n      this.facingNext = true\n\n      if (this.currentIndex < this.points.length - 1) {\n        transform.lookAt(this.points[this.currentIndex + 1])\n      } else {\n        transform.lookAt(this.points[0])\n      }\n    }\n  }\n}\n","import { ITransformComponent } from './itransformcomponent'\nimport { TransformSystem } from '../system/transfromSystem'\n\n/**\n * Component to rotate entity indefinitely until stop is called\n */\n@Component('keepRotatingComponent')\nexport class KeepRotatingComponent implements ITransformComponent {\n  onFinishCallback?: () => void\n\n  private rotationVelocity: Quaternion\n  private rotation: Quaternion\n  private finished: boolean\n\n  /**\n   * Rotates an entity continuously. The entity will keep rotating forever until it's explicitly stopped or the component is removed.\n   * @param {Quaternion} rotationVelocity a quaternion describing the desired rotation to perform each second second\n   * @param {() => void} onFinishCallback called when rotation ends\n   */\n  constructor(rotationVelocity: Quaternion, onFinishCallback?: () => void) {\n    this.rotationVelocity = rotationVelocity\n    this.onFinishCallback = onFinishCallback\n    this.rotation = Quaternion.Identity\n    this.finished = false\n\n    let instance = TransformSystem.createAndAddToEngine()\n    instance.addComponentType(KeepRotatingComponent)\n  }\n\n  update(dt: number): void {\n    this.rotation = Quaternion.Slerp(\n      Quaternion.Identity,\n      this.rotationVelocity,\n      dt\n    )\n  }\n\n  hasFinished(): boolean {\n    return this.finished\n  }\n\n  assignValueToTransform(transform: Transform): void {\n    transform.rotation = transform.rotation.multiply(this.rotation)\n  }\n\n  stop() {\n    this.finished = true\n  }\n}\n","import { ITimerComponent } from '../component/itimercomponent'\r\n\r\nexport class TimerSystem implements ISystem {\r\n  private static _instance: TimerSystem | null = null\r\n\r\n  private _components: ComponentConstructor<ITimerComponent>[] = []\r\n\r\n  static createAndAddToEngine(): TimerSystem {\r\n    if (this._instance == null) {\r\n      this._instance = new TimerSystem()\r\n      engine.addSystem(this._instance)\r\n    }\r\n    return this._instance\r\n  }\r\n\r\n  static registerCustomComponent<T extends ITimerComponent>(\r\n    component: ComponentConstructor<T>\r\n  ) {\r\n    this.createAndAddToEngine()._components.push(component)\r\n  }\r\n\r\n  public addComponentType(component: ComponentConstructor<ITimerComponent>) {\r\n    for (let comp of this._components) {\r\n      if (component == comp) {\r\n        return\r\n      }\r\n    }\r\n    this._components.push(component)\r\n  }\r\n\r\n  private constructor() {\r\n    TimerSystem._instance = this\r\n  }\r\n\r\n  update(dt: number) {\r\n    this._components.forEach(component => {\r\n      this.updateComponent(dt, component)\r\n    })\r\n  }\r\n\r\n  private updateComponent<T extends ITimerComponent>(\r\n    dt: number,\r\n    component: ComponentConstructor<T>\r\n  ) {\r\n    let record = engine.getEntitiesWithComponent(component)\r\n\r\n    for (const key in record) {\r\n      if (record.hasOwnProperty(key)) {\r\n        let entity = record[key]\r\n        let timerComponent = entity.getComponent(component)\r\n\r\n        timerComponent.elapsedTime += dt\r\n        if (timerComponent.elapsedTime >= timerComponent.targetTime) {\r\n          timerComponent.onTargetTimeReached(entity)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ITimerComponent } from './itimercomponent'\r\nimport { TimerSystem } from '../system/timerSystem'\r\n\r\n/**\r\n * Execute once after X milliseconds\r\n */\r\n@Component('timerDelay')\r\nexport class Delay implements ITimerComponent {\r\n  elapsedTime: number\r\n  targetTime: number\r\n  onTargetTimeReached: (ownerEntity: IEntity) => void\r\n\r\n  private onTimeReachedCallback?: () => void\r\n\r\n  /**\r\n   * @param {number} millisecs amount of time in milliseconds\r\n   * @param {() => void} onTimeReachedCallback callback for when time is reached\r\n   */\r\n  constructor(millisecs: number, onTimeReachedCallback?: () => void) {\r\n    let instance = TimerSystem.createAndAddToEngine()\r\n    instance.addComponentType(Delay)\r\n\r\n    this.elapsedTime = 0\r\n    this.targetTime = millisecs / 1000\r\n    this.onTimeReachedCallback = onTimeReachedCallback\r\n    this.onTargetTimeReached = entity => {\r\n      if (this.onTimeReachedCallback) this.onTimeReachedCallback()\r\n      entity.removeComponent(this)\r\n    }\r\n  }\r\n\r\n  setCallback(onTimeReachedCallback: () => void) {\r\n    this.onTimeReachedCallback = onTimeReachedCallback\r\n  }\r\n}\r\n","import { ITimerComponent } from './itimercomponent'\r\nimport { TimerSystem } from '../system/timerSystem'\r\n\r\n/**\r\n * Remove entity after X milliseconds\r\n */\r\n@Component('timerExpireIn')\r\nexport class ExpireIn implements ITimerComponent {\r\n  elapsedTime: number\r\n  targetTime: number\r\n  onTargetTimeReached: (ownerEntity: IEntity) => void\r\n\r\n  private onTimeReachedCallback?: () => void\r\n\r\n  /**\r\n   * @param {number} millisecs amount of time in milliseconds\r\n   * @param {() => void} onTimeReachedCallback callback for when time is reached\r\n   */\r\n  constructor(millisecs: number, onTimeReachedCallback?: () => void) {\r\n    let instance = TimerSystem.createAndAddToEngine()\r\n    instance.addComponentType(ExpireIn)\r\n\r\n    this.elapsedTime = 0\r\n    this.targetTime = millisecs / 1000\r\n    this.onTimeReachedCallback = onTimeReachedCallback\r\n    this.onTargetTimeReached = entity => {\r\n      if (this.onTimeReachedCallback) this.onTimeReachedCallback()\r\n      entity.removeComponent(this)\r\n      engine.removeEntity(entity)\r\n    }\r\n  }\r\n\r\n  setCallback(onTimeReachedCallback: () => void) {\r\n    this.onTimeReachedCallback = onTimeReachedCallback\r\n  }\r\n}\r\n","import { ITimerComponent } from './itimercomponent'\r\nimport { TimerSystem } from '../system/timerSystem'\r\n\r\n/**\r\n * Execute every X milliseconds\r\n */\r\n@Component('timerInterval')\r\nexport class Interval implements ITimerComponent {\r\n  elapsedTime: number\r\n  targetTime: number\r\n  onTargetTimeReached: (ownerEntity: IEntity) => void\r\n\r\n  private onTimeReachedCallback?: () => void\r\n\r\n  /**\r\n   * @param {number} millisecs amount of time in milliseconds\r\n   * @param {() => void} onTimeReachedCallback callback for when time is reached\r\n   */\r\n  constructor(millisecs: number, onTimeReachedCallback?: () => void) {\r\n    let instance = TimerSystem.createAndAddToEngine()\r\n    instance.addComponentType(Interval)\r\n\r\n    this.elapsedTime = 0\r\n    this.targetTime = millisecs / 1000\r\n    this.onTimeReachedCallback = onTimeReachedCallback\r\n    this.onTargetTimeReached = () => {\r\n      this.elapsedTime = 0\r\n      if (this.onTimeReachedCallback) this.onTimeReachedCallback()\r\n    }\r\n  }\r\n\r\n  setCallback(onTimeReachedCallback: () => void) {\r\n    this.onTimeReachedCallback = onTimeReachedCallback\r\n  }\r\n}\r\n","import { isPreviewMode } from '@decentraland/EnvironmentAPI'\n\n/**\n * Quick function to add a cube that can run functions when clicked. By default only displayed when in preview mode for tests.\n *\n * @param {TranformConstructorArgs} pos Transform arguments for the cube, including position, scale and rotation\n * @param {() => void} triggeredFunction Function to execute every time the cube is clicked.\n * @param {string} label Text to display over cube and on hover.\n * @param {Color3} color Cube color.\n * @param {boolean} sphere If true, use a sphere shape instead of cube.\n * @param {boolean} noCollider If true, cube has no collider.\n * @return {Entity} A new entity with the configured settings and a label as a child\n *\n */\nexport async function addTestCube(\n  pos: TranformConstructorArgs,\n  triggeredFunction: () => void,\n  label?: string,\n  color?: Color3,\n  sphere?: boolean,\n  noCollider?: boolean,\n  keepInProduction?: boolean\n) {\n  // if not in preview return\n  if (!keepInProduction && (await !isPreviewMode())) {\n    return\n  }\n\n  let cube = new Entity()\n  cube.addComponent(new Transform(pos))\n  if (sphere) {\n    cube.addComponent(new SphereShape())\n    cube.getComponent(Transform).scale.setAll(0.5)\n  } else {\n    cube.addComponent(new BoxShape())\n  }\n\n  engine.addEntity(cube)\n\n  cube.addComponent(\n    new OnPointerDown(triggeredFunction, {\n      hoverText: label ? label : 'click',\n      button: ActionButton.POINTER\n    })\n  )\n\n  if (color) {\n    let cubeMaterial = new Material()\n    cubeMaterial.albedoColor = color\n    cube.addComponent(cubeMaterial)\n  }\n\n  if (noCollider) {\n    cube.getComponent(BoxShape).withCollisions = false\n  }\n\n  if (label) {\n    addLabel(label, cube, true)\n  }\n\n  return cube\n}\n\n/**\n * Maps a value from one range of values to its equivalent, scaled in proportion to another range of values, using maximum and minimum.\n *\n * @param {string} text Text to use on label\n * @param {Entity} parent Entity to place label on.\n * @param {boolean} billboard If true, label turns to always face player.\n * @param {Color3} color Text color. Black by default.\n * @param {number} size Text font size, 3 by default.\n * @param {TranformConstructorArgs} textOffset Offset from parent entity's position. By default 1.5 meters above the parent.\n * @return {Entity} A new entity with the configured settings that is a child of the provided parent\n *\n */\nexport function addLabel(\n  text: string,\n  parent: IEntity,\n  billboard?: boolean,\n  color?: Color3,\n  size?: number,\n  textOffset?: TranformConstructorArgs\n) {\n  let label = new Entity()\n  label.addComponent(\n    new Transform(\n      textOffset ? textOffset : { position: new Vector3(0, 1.5, 0) }\n    )\n  )\n  label.setParent(parent)\n  let textShape = new TextShape(text)\n  textShape.fontSize = size ? size : 3\n  textShape.color = color ? color : Color3.Black()\n  label.addComponent(textShape)\n  if (billboard) {\n    label.addComponent(new Billboard())\n  }\n  engine.addEntity(label)\n\n  return label\n}\n","export class ActionsSequenceSystem implements ISystem {\n  private beginSequenceNode: SequenceNode | null = null\n  private currentSequenceNode: SequenceNode | null = null\n\n  private running: boolean = false\n  private started: boolean = false\n\n  private onFinishCallback?: () => void\n\n  constructor(sequenceBuilt?: ActionsSequenceSystem.SequenceBuilder) {\n    if (sequenceBuilt) {\n      this.startSequence(sequenceBuilt)\n    }\n  }\n\n  startSequence(sequenceBuilt: ActionsSequenceSystem.SequenceBuilder) {\n    this.beginSequenceNode = sequenceBuilt.beginSequenceNode\n    this.currentSequenceNode = this.beginSequenceNode\n    this.running = true\n    this.started = false\n  }\n\n  setOnFinishCallback(onFinishCallback: () => void) {\n    this.onFinishCallback = onFinishCallback\n  }\n\n  isRunning(): boolean {\n    return this.running\n  }\n\n  stop() {\n    this.running = false\n  }\n\n  resume() {\n    if (this.beginSequenceNode != null) {\n      this.running = true\n    }\n  }\n\n  reset() {\n    this.currentSequenceNode = this.beginSequenceNode\n    this.running = true\n    this.started = false\n  }\n\n  getRunningAction(): ActionsSequenceSystem.IAction | null {\n    let currentNode: SequenceNode | null = this.currentSequenceNode\n\n    if (this.currentSequenceNode instanceof SubSequenceNode) {\n      do {\n        currentNode = (currentNode as SubSequenceNode).currentInnerSequence\n      } while (currentNode instanceof SubSequenceNode)\n    }\n    return (currentNode as SequenceNode).action\n  }\n\n  update(dt: number): void {\n    if (this.running) {\n      if (!this.started) {\n        ;(this.currentSequenceNode as SequenceNode).onStart()\n        this.started = true\n      } else {\n        if (!(this.currentSequenceNode as SequenceNode).hasFinish()) {\n          ;(this.currentSequenceNode as SequenceNode).update(dt)\n        } else {\n          ;(this.currentSequenceNode as SequenceNode).onFinish()\n          this.currentSequenceNode = (this\n            .currentSequenceNode as SequenceNode).next\n          if (this.currentSequenceNode) {\n            this.currentSequenceNode.onStart()\n          } else {\n            this.running = false\n            if (this.onFinishCallback) this.onFinishCallback()\n          }\n        }\n      }\n    }\n  }\n}\n\nexport namespace ActionsSequenceSystem {\n  export interface IAction {\n    onStart(): void\n    update(dt: number): void\n    onFinish(): void\n    hasFinished: boolean\n  }\n\n  export class SequenceBuilder {\n    private currentSequenceNode: SequenceNode | null = null\n    public beginSequenceNode: SequenceNode | null = null\n\n    private whileNodeStack: WhileSequenceNode[] = []\n\n    then(action: ActionsSequenceSystem.IAction): SequenceBuilder {\n      if (this.currentSequenceNode == null) {\n        this.currentSequenceNode = new SequenceNode()\n        this.currentSequenceNode.action = action\n        this.beginSequenceNode = this.currentSequenceNode\n      } else {\n        let next = new SequenceNode()\n        next.action = action\n        this.currentSequenceNode = this.currentSequenceNode.then(next)\n      }\n      return this\n    }\n\n    if(condition: () => boolean): SequenceBuilder {\n      let ifSeq = new IfSequenceNode(condition)\n      if (this.currentSequenceNode == null) {\n        this.currentSequenceNode = ifSeq\n        this.beginSequenceNode = ifSeq\n      } else {\n        this.currentSequenceNode = this.currentSequenceNode.then(ifSeq)\n      }\n      return this\n    }\n\n    else(): SequenceBuilder {\n      let seq = (this.currentSequenceNode as SequenceNode).getSequence()\n      if (seq instanceof IfSequenceNode) {\n        seq.closed = true\n        let elseSeq = new ElseSequenceNode(seq)\n        this.currentSequenceNode = (this\n          .currentSequenceNode as SequenceNode).then(elseSeq)\n      } else {\n        throw new Error(\n          'IF statement is needed to be called before ELSE statement.'\n        )\n      }\n      return this\n    }\n\n    endIf(): SequenceBuilder {\n      let seq = (this.currentSequenceNode as SequenceNode).getSequence()\n      if (seq instanceof IfSequenceNode || seq instanceof ElseSequenceNode) {\n        seq.closed = true\n      } else {\n        throw new Error(\n          'IF statement is needed to be called before ENDIF statement.'\n        )\n      }\n      return this\n    }\n\n    while(condition: () => boolean): SequenceBuilder {\n      let whileSeq = new WhileSequenceNode(condition)\n      if (this.currentSequenceNode == null) {\n        this.currentSequenceNode = whileSeq\n        this.beginSequenceNode = whileSeq\n      } else {\n        this.currentSequenceNode = this.currentSequenceNode.then(whileSeq)\n      }\n      this.whileNodeStack.push(whileSeq)\n      return this\n    }\n\n    endWhile(): SequenceBuilder {\n      let seq = (this.currentSequenceNode as SequenceNode).getSequence()\n      if (seq instanceof WhileSequenceNode) {\n        seq.closed = true\n        if (this.whileNodeStack.length > 0) {\n          this.whileNodeStack.splice(this.whileNodeStack.length - 1, 1)\n        }\n      } else {\n        throw new Error(\n          'WHILE statement is needed to be called before ENDWHILE statement.'\n        )\n      }\n      return this\n    }\n\n    breakWhile(): SequenceBuilder {\n      if (this.whileNodeStack.length > 0) {\n        this.currentSequenceNode = (this\n          .currentSequenceNode as SequenceNode).then(\n          new BreakWhileSequenceNode(\n            this.whileNodeStack[this.whileNodeStack.length - 1]\n          )\n        )\n      } else {\n        throw new Error(\n          'WHILE statement is needed to be called before BREAKWHILE statement.'\n        )\n      }\n      return this\n    }\n  }\n}\n\nclass SequenceNode {\n  action: ActionsSequenceSystem.IAction | null = null\n  next: SequenceNode | null = null\n\n  then(next: SequenceNode): SequenceNode {\n    this.next = next\n    return next\n  }\n\n  onStart() {\n    if (this.action) this.action.onStart()\n  }\n\n  update(dt: number) {\n    if (this.action) this.action.update(dt)\n  }\n\n  onFinish() {\n    if (this.action) this.action.onFinish()\n  }\n\n  hasFinish(): boolean {\n    if (this.action) return this.action.hasFinished\n    else return true\n  }\n\n  getSequence(): SequenceNode {\n    return this\n  }\n}\n\nclass SubSequenceNode extends SequenceNode {\n  currentInnerSequence: SequenceNode | null = null\n  startingInnerSequence: SequenceNode | null = null\n  closed: boolean = false\n\n  then(next: SequenceNode): SequenceNode {\n    if (this.currentInnerSequence == null) {\n      this.currentInnerSequence = next\n      this.startingInnerSequence = next\n    } else {\n      if (this.closed) {\n        this.next = next\n        return next\n      } else {\n        this.currentInnerSequence = this.currentInnerSequence.then(next)\n      }\n    }\n    return this\n  }\n\n  onStart() {\n    this.currentInnerSequence = this.startingInnerSequence\n    if (this.currentInnerSequence) this.currentInnerSequence.onStart()\n  }\n\n  update(dt: number) {\n    if (this.currentInnerSequence) {\n      if (!this.currentInnerSequence.hasFinish()) {\n        this.currentInnerSequence.update(dt)\n      } else {\n        this.currentInnerSequence.onFinish()\n        this.currentInnerSequence = this.currentInnerSequence.next\n        if (this.currentInnerSequence) this.currentInnerSequence.onStart()\n      }\n    }\n  }\n\n  onFinish() {\n    if (this.currentInnerSequence) this.currentInnerSequence.onFinish()\n  }\n\n  hasFinish(): boolean {\n    return this.currentInnerSequence == null\n  }\n\n  getSequence(): SequenceNode {\n    if (this.currentInnerSequence) {\n      let innerSeq = this.currentInnerSequence.getSequence()\n      if (innerSeq instanceof SubSequenceNode) {\n        if (!innerSeq.closed) {\n          return innerSeq\n        }\n      }\n    }\n    return this\n  }\n}\n\nclass IfSequenceNode extends SubSequenceNode {\n  condition: () => boolean\n  result: boolean = false\n\n  constructor(condition: () => boolean) {\n    super()\n    this.condition = condition\n  }\n\n  onStart() {\n    this.result = this.condition()\n    if (this.result) super.onStart()\n    else this.currentInnerSequence = null\n  }\n}\n\nclass ElseSequenceNode extends SubSequenceNode {\n  ifSequence: IfSequenceNode | null = null\n\n  constructor(ifSequence: IfSequenceNode) {\n    super()\n    this.ifSequence = ifSequence\n  }\n\n  onStart() {\n    if (this.ifSequence && !this.ifSequence.result) super.onStart()\n    else this.currentInnerSequence = null\n  }\n}\n\nclass WhileSequenceNode extends SubSequenceNode {\n  condition: () => boolean\n  breakWhile: boolean = false\n\n  constructor(condition: () => boolean) {\n    super()\n    this.condition = condition\n  }\n\n  onStart() {\n    this.breakWhile = false\n    if (this.condition()) super.onStart()\n    else this.currentInnerSequence = null\n  }\n\n  update(dt: number) {\n    if (this.currentInnerSequence) {\n      if (!this.currentInnerSequence.hasFinish()) {\n        this.currentInnerSequence.update(dt)\n      } else {\n        this.currentInnerSequence.onFinish()\n        this.currentInnerSequence = this.currentInnerSequence.next\n        if (this.currentInnerSequence == null)\n          this.currentInnerSequence = this.startingInnerSequence\n        if (this.currentInnerSequence) this.currentInnerSequence.onStart()\n      }\n    }\n  }\n\n  hasFinish(): boolean {\n    return this.breakWhile || !this.condition()\n  }\n}\n\nclass BreakWhileSequenceNode extends SequenceNode {\n  whileNode: WhileSequenceNode\n\n  constructor(whileNode: WhileSequenceNode) {\n    super()\n    this.whileNode = whileNode\n  }\n\n  onStart() {\n    this.whileNode.breakWhile = true\n  }\n}\n","import { isPreviewMode } from '@decentraland/EnvironmentAPI'\n\n/**\n *\n * @typedef {Object} TriggerData - Object with data for a NPCTriggerComponent\n * @property {number} layer  layer of the Trigger, useful to discriminate between trigger events. You can set multiple layers by using a | symbol.\n * @property {number} triggeredByLayer against which layers to check collisions\n * @property {(entity: Entity) => void } onTriggerEnter callback when an entity of a valid layer enters the trigger area\n * @property {(entity: Entity) => void} onTriggerExit callback when an entity of a valid layer leaves the trigger area\n * @property {() => void} onCameraEnter callback when the player enters the trigger area\n * @property {() => void} onCameraExit callback when the player leaves the trigger area\n * @property {boolean} enableDebug when true makes the trigger area visible for debug purposes.\n */\nexport type TriggerData = {\n  layer?: number\n  triggeredByLayer?: number\n  onTriggerEnter?: (entity: Entity) => void\n  onTriggerExit?: (entity: Entity) => void\n  onCameraEnter?: () => void\n  onCameraExit?: () => void\n  enableDebug?: boolean\n}\n\nexport class TriggerSystem implements ISystem {\n  private static _instance: TriggerSystem | null = null\n  static get instance(): TriggerSystem {\n    return this.createAndAddToEngine()\n  }\n\n  private _triggers: Record<string, TriggerWrapper> = {}\n  private _cameraTriggerWrapper: CameraTrigger\n  private _componentGroup: ComponentGroup\n\n  private constructor() {\n    TriggerSystem._instance = this\n    this._cameraTriggerWrapper = new CameraTrigger(\n      new TriggerBoxShape(new Vector3(0.5, 1.8, 0.5), new Vector3(0, 0.91, 0))\n    )\n\n    this._componentGroup = engine.getComponentGroup(TriggerComponent)\n  }\n\n  static createAndAddToEngine(): TriggerSystem {\n    if (this._instance == null) {\n      this._instance = new TriggerSystem()\n      engine.addSystem(this._instance)\n    }\n    return this._instance\n  }\n\n  /**\n   * set a custom trigger's shape for the camera\n   * @param {TriggerBoxShape | TriggerSphereShape} shape custom trigger's shape\n   */\n  setCameraTriggerShape(shape: TriggerBoxShape | TriggerSphereShape) {\n    this._cameraTriggerWrapper.setShape(shape)\n  }\n\n  update() {\n    let entitiesWithTriggers = this._componentGroup.entities\n\n    //iterate through all entities with triggers and wrap entities that weren't wrapped yet\n    entitiesWithTriggers.forEach(entity => {\n      if (this.shouldWrapTriggerEntity(entity)) {\n        this.wrapTriggerEntity(entity)\n      }\n    })\n\n    //iterate through wrapped entities\n    for (const key in this._triggers) {\n      if (this._triggers.hasOwnProperty(key)) {\n        let wrapper = this._triggers[key]\n\n        //update debug entity\n        if (wrapper.isDebugging()) {\n          wrapper.updateDebugEntity()\n        }\n\n        if (!wrapper.isInEngine()) {\n          //remove debugging\n          if (wrapper.isDebugging()) {\n            wrapper.removeDebugEntity()\n          }\n          //remove old collisions\n          TriggerSystem.removeTriggerFromSystem(wrapper)\n          //remove from record\n          delete this._triggers[key]\n        } else if (wrapper.trigger != null && wrapper.trigger.enabled) {\n          //if was set as enabled in last frame\n          if (!wrapper.wasEnabled) {\n            if (wrapper.isDebugging()) {\n              wrapper.addDebugEntity()\n            }\n          }\n          //set as enabled\n          wrapper.wasEnabled = true\n\n          //check collision camera\n          if (wrapper.trigger.onCameraEnter || wrapper.trigger.onCameraExit) {\n            this.checkCollisionAgainstCamera(wrapper)\n          }\n\n          //check collision with others\n          if (wrapper.trigger.onTriggerEnter || wrapper.trigger.onTriggerExit) {\n            this.checkCollisionAgainstOtherTriggers(wrapper)\n          }\n        } else if (wrapper.wasEnabled) {\n          wrapper.wasEnabled = false\n          //remove debugging\n          if (wrapper.isDebugging()) {\n            wrapper.removeDebugEntity()\n          }\n          TriggerSystem.removeTriggerFromSystem(wrapper)\n        }\n      }\n    }\n  }\n\n  private shouldWrapTriggerEntity(entity: IEntity): boolean {\n    return (\n      this._triggers[entity.uuid] == undefined ||\n      this._triggers[entity.uuid] == null\n    )\n  }\n\n  private wrapTriggerEntity(entity: IEntity) {\n    this._triggers[entity.uuid] = new TriggerWrapper(entity as Entity)\n  }\n\n  private static removeTriggerFromSystem(wrapper: TriggerWrapper) {\n    let activeCollisions = wrapper.getActiveCollisions()\n    for (let i = 0; i < activeCollisions.length; i++) {\n      let activeCollisionHasTrigger = !(\n        activeCollisions[i] ===\n          TriggerSystem._instance?._cameraTriggerWrapper ||\n        activeCollisions[i].trigger == null\n      )\n\n      if (\n        activeCollisionHasTrigger &&\n        activeCollisions[i].trigger.onTriggerExit &&\n        wrapper.entity\n      )\n        (activeCollisions[i].trigger.onTriggerExit as (\n          entity: IEntity\n        ) => void)(wrapper.entity)\n      activeCollisions[i].disengageActiveCollision(wrapper)\n      wrapper.disengageActiveCollision(activeCollisions[i])\n    }\n  }\n\n  private static disengageCollision(t1: TriggerWrapper, t2: TriggerWrapper) {\n    t1.disengageActiveCollision(t2)\n    t2.disengageActiveCollision(t1)\n\n    if (t1.trigger.onTriggerExit && t2.entity)\n      t1.trigger.onTriggerExit(t2.entity)\n    if (t2.trigger.onTriggerExit && t1.entity)\n      t2.trigger.onTriggerExit(t1.entity)\n  }\n\n  private static engageCollision(t1: TriggerWrapper, t2: TriggerWrapper) {\n    t1.engageCollision(t2)\n    t2.engageCollision(t1)\n\n    if (t1.trigger.onTriggerEnter && t2.entity)\n      t1.trigger.onTriggerEnter(t2.entity)\n    if (t2.trigger.onTriggerEnter && t1.entity)\n      t2.trigger.onTriggerEnter(t1.entity)\n  }\n\n  private checkCollisionAgainstCamera(wrapper: TriggerWrapper) {\n    let wereColliding = wrapper.hasActiveCollision(this._cameraTriggerWrapper)\n    let areColliding = TriggerSystem.areColliding(\n      wrapper,\n      this._cameraTriggerWrapper\n    )\n\n    if (wereColliding && !areColliding) {\n      wrapper.disengageActiveCollision(this._cameraTriggerWrapper)\n      if (wrapper.trigger.onCameraExit) wrapper.trigger.onCameraExit()\n    } else if (!wereColliding && areColliding) {\n      wrapper.engageCollision(this._cameraTriggerWrapper)\n      if (wrapper.trigger.onCameraEnter) wrapper.trigger.onCameraEnter()\n    }\n  }\n\n  private checkCollisionAgainstOtherTriggers(wrapper: TriggerWrapper) {\n    for (const key in this._triggers) {\n      if (this._triggers.hasOwnProperty(key)) {\n        if (key != wrapper.uuid && this._triggers[key].trigger.enabled) {\n          if (TriggerSystem.canTriggersCollide(wrapper, this._triggers[key])) {\n            let wereColliding = wrapper.hasActiveCollision(this._triggers[key])\n            let areColliding = TriggerSystem.areColliding(\n              wrapper,\n              this._triggers[key]\n            )\n\n            if (wereColliding && !areColliding)\n              TriggerSystem.disengageCollision(wrapper, this._triggers[key])\n            else if (!wereColliding && areColliding)\n              TriggerSystem.engageCollision(wrapper, this._triggers[key])\n          }\n        }\n      }\n    }\n  }\n\n  private static canTriggersCollide(\n    t1: TriggerWrapper,\n    t2: TriggerWrapper\n  ): boolean {\n    if (t1.trigger.triggeredByLayer == 0) return true\n    return (t2.trigger.layer & t1.trigger.triggeredByLayer) != 0\n  }\n\n  private static areColliding(t1: TriggerWrapper, t2: TriggerWrapper): boolean {\n    if (\n      t1.getShape() instanceof TriggerBoxShape &&\n      t2.getShape() instanceof TriggerBoxShape\n    ) {\n      return TriggerSystem.areCollidingAABB(\n        t1.getGlobalPosition(),\n        t1.getShape() as TriggerBoxShape,\n        t2.getGlobalPosition(),\n        t2.getShape() as TriggerBoxShape\n      )\n    } else if (\n      t1.getShape() instanceof TriggerSphereShape &&\n      t2.getShape() instanceof TriggerSphereShape\n    ) {\n      return TriggerSystem.areCollidingSphere(\n        t1.getGlobalPosition(),\n        t1.getShape() as TriggerSphereShape,\n        t2.getGlobalPosition(),\n        t2.getShape() as TriggerSphereShape\n      )\n    } else if (\n      t1.getShape() instanceof TriggerBoxShape &&\n      t2.getShape() instanceof TriggerSphereShape\n    ) {\n      return TriggerSystem.areCollidingAABBSphere(\n        t1.getGlobalPosition(),\n        t1.getShape() as TriggerBoxShape,\n        t2.getGlobalPosition(),\n        t2.getShape() as TriggerSphereShape\n      )\n    } else if (\n      t1.getShape() instanceof TriggerSphereShape &&\n      t2.getShape() instanceof TriggerBoxShape\n    ) {\n      return TriggerSystem.areCollidingAABBSphere(\n        t2.getGlobalPosition(),\n        t2.getShape() as TriggerBoxShape,\n        t1.getGlobalPosition(),\n        t1.getShape() as TriggerSphereShape\n      )\n    }\n    return false\n  }\n\n  private static areCollidingAABB(\n    t1GlobalPosition: Vector3,\n    t1Shape: TriggerBoxShape,\n    t2GlobalPosition: Vector3,\n    t2Shape: TriggerBoxShape\n  ): boolean {\n    let t1 = TriggerSystem.getBoxShapeValues(t1GlobalPosition, t1Shape)\n    let t2 = TriggerSystem.getBoxShapeValues(t2GlobalPosition, t2Shape)\n    return (\n      t1.min.x <= t2.max.x &&\n      t1.max.x >= t2.min.x &&\n      t1.min.y <= t2.max.y &&\n      t1.max.y >= t2.min.y &&\n      t1.min.z <= t2.max.z &&\n      t1.max.z >= t2.min.z\n    )\n  }\n\n  private static areCollidingSphere(\n    t1GlobalPosition: Vector3,\n    t1Shape: TriggerSphereShape,\n    t2GlobalPosition: Vector3,\n    t2Shape: TriggerSphereShape\n  ): boolean {\n    let sqDist = Vector3.DistanceSquared(\n      t1GlobalPosition.add(t1Shape.position),\n      t2GlobalPosition.add(t2Shape.position)\n    )\n    return (\n      sqDist < t1Shape.radius * t1Shape.radius + t2Shape.radius * t2Shape.radius\n    )\n  }\n\n  private static areCollidingAABBSphere(\n    t1GlobalPosition: Vector3,\n    t1Shape: TriggerBoxShape,\n    t2GlobalPosition: Vector3,\n    t2Shape: TriggerSphereShape\n  ): boolean {\n    let box = TriggerSystem.getBoxShapeValues(t1GlobalPosition, t1Shape)\n    let sphere = {\n      center: t2GlobalPosition.add(t2Shape.position),\n      radius: t2Shape.radius\n    }\n\n    let dmin = 0\n    if (sphere.center.x < box.min.x)\n      dmin += (box.min.x - sphere.center.x) * (box.min.x - sphere.center.x)\n    if (sphere.center.x > box.max.x)\n      dmin += (sphere.center.x - box.max.x) * (sphere.center.x - box.max.x)\n    if (sphere.center.y < box.min.y)\n      dmin += (box.min.y - sphere.center.y) * (box.min.y - sphere.center.y)\n    if (sphere.center.y > box.max.y)\n      dmin += (sphere.center.y - box.max.y) * (sphere.center.y - box.max.y)\n    if (sphere.center.z < box.min.z)\n      dmin += (box.min.z - sphere.center.z) * (box.min.z - sphere.center.z)\n    if (sphere.center.z > box.max.z)\n      dmin += (sphere.center.z - box.max.z) * (sphere.center.z - box.max.z)\n\n    return dmin < sphere.radius * sphere.radius\n  }\n\n  private static getBoxShapeValues(\n    entityGlobalPosition: Vector3,\n    shape: TriggerBoxShape\n  ): { center: Vector3; min: Vector3; max: Vector3 } {\n    let center = entityGlobalPosition.add(shape.position)\n    return {\n      center: center,\n      min: center.subtract(shape.size.scale(0.5)),\n      max: center.add(shape.size.scale(0.5))\n    }\n  }\n}\n\nclass TriggerWrapper {\n  wasEnabled: boolean = true\n\n  get entity(): Entity | undefined {\n    return this._entity\n  }\n  get trigger(): TriggerComponent {\n    return this._trigger\n  }\n  get uuid(): string {\n    return this._uuid\n  }\n\n  protected _entity?: Entity\n  protected _trigger!: TriggerComponent\n  protected _uuid: string = ''\n  protected _collidingWith: Record<string, TriggerWrapper> = {}\n\n  private _isDebug: boolean = false\n  private _debugEntity: Entity | null = null\n  private static _debugMaterial: Material | null = null\n\n  constructor(entity?: Entity) {\n    this._entity = entity\n    if (entity) {\n      this._trigger = entity.getComponent(TriggerComponent)\n      this._uuid = entity.uuid\n      this._isDebug = this._trigger.debugEnabled\n      if (this._isDebug) {\n        this.addDebugEntity()\n      }\n    }\n  }\n\n  getGlobalPosition(): Vector3 {\n    if (this._entity) return TriggerWrapper.getEntityWorldPosition(this._entity)\n    return Vector3.Zero()\n  }\n\n  getShape(): TriggerBoxShape | TriggerSphereShape {\n    return this._trigger.shape\n  }\n\n  isInEngine(): boolean {\n    return this._entity != null && this._entity.isAddedToEngine()\n  }\n\n  getActiveCollisions(): TriggerWrapper[] {\n    let ret: TriggerWrapper[] = []\n\n    for (const key in this._collidingWith) {\n      if (this._collidingWith.hasOwnProperty(key)) {\n        ret.push(this._collidingWith[key])\n      }\n    }\n    return ret\n  }\n\n  hasActiveCollision(other: TriggerWrapper): boolean {\n    return (\n      this._collidingWith[other.uuid] != undefined &&\n      this._collidingWith[other.uuid] != null\n    )\n  }\n\n  disengageActiveCollision(other: TriggerWrapper) {\n    delete this._collidingWith[other.uuid]\n  }\n\n  engageCollision(other: TriggerWrapper) {\n    this._collidingWith[other.uuid] = other\n  }\n\n  isDebugging(): boolean {\n    return this._isDebug\n  }\n\n  async addDebugEntity() {\n    if (await !isPreviewMode()) {\n      return\n    }\n\n    if (!TriggerWrapper._debugMaterial) {\n      TriggerWrapper._debugMaterial = new Material()\n      TriggerWrapper._debugMaterial.alphaTest = 0.5\n    }\n\n    if (this._debugEntity == null) {\n      this._debugEntity = new Entity()\n\n      const transform = new Transform()\n      this._debugEntity.addComponent(transform)\n      this._debugEntity.addComponent(TriggerWrapper._debugMaterial)\n\n      if (this.getShape() instanceof TriggerBoxShape) {\n        const shape = new BoxShape()\n        shape.withCollisions = false\n        this._debugEntity.addComponent(shape)\n        transform.scale = (this.getShape() as TriggerBoxShape).size\n      }\n      if (this.getShape() instanceof TriggerSphereShape) {\n        const shape = new SphereShape()\n        shape.withCollisions = false\n        this._debugEntity.addComponent(shape)\n        let rad = (this.getShape() as TriggerSphereShape).radius\n        transform.scale = new Vector3(rad, rad, rad)\n      }\n    }\n    engine.addEntity(this._debugEntity)\n  }\n\n  removeDebugEntity() {\n    if (this._debugEntity != null) engine.removeEntity(this._debugEntity)\n  }\n\n  updateDebugEntity() {\n    if (this._debugEntity) {\n      this._debugEntity.getComponent(\n        Transform\n      ).position = this.getGlobalPosition().add(this.getShape().position)\n    }\n  }\n\n  private static getEntityWorldPosition(entity: IEntity): Vector3 {\n    let entityPosition = entity.hasComponent(Transform)\n      ? entity.getComponent(Transform).position.clone()\n      : Vector3.Zero()\n    let parentEntity = entity.getParent()\n\n    if (parentEntity != null) {\n      let parentRotation = parentEntity.hasComponent(Transform)\n        ? parentEntity.getComponent(Transform).rotation\n        : Quaternion.Identity\n      return this.getEntityWorldPosition(parentEntity).add(\n        entityPosition.rotate(parentRotation)\n      )\n    }\n    return entityPosition\n  }\n}\n\nclass CameraTrigger extends TriggerWrapper {\n  private _shape: TriggerBoxShape | TriggerSphereShape\n\n  constructor(shape: TriggerBoxShape | TriggerSphereShape) {\n    super()\n    this._shape = shape\n    this._uuid = 'cameraTrigger'\n  }\n\n  getGlobalPosition() {\n    return Camera.instance.position\n  }\n\n  getShape() {\n    return this._shape\n  }\n\n  setShape(shape: TriggerBoxShape | TriggerSphereShape) {\n    this._shape = shape\n  }\n\n  isInEngine(): boolean {\n    return false\n  }\n\n  hasActiveCollision(other: TriggerWrapper): boolean {\n    return false\n  }\n\n  disengageActiveCollision(other: TriggerWrapper) {}\n\n  engageCollision(other: TriggerWrapper) {}\n  isDebugging(): boolean {\n    return false\n  }\n}\n\n@Component('triggerComponent')\nexport class TriggerComponent {\n  /**\n   * Is the trigger enabled? If false, the associated functions aren't triggered.\n   */\n  enabled: boolean = true\n  /**\n   * shape of the collider\n   */\n  shape: TriggerBoxShape | TriggerSphereShape\n  /**\n   * bit layer of the Tigger (usefull to discriminate between trigger events)\n   */\n  layer: number = 0\n  /**\n   * against which layer are we going to check trigger's collisions\n   */\n  triggeredByLayer: number = 0\n  /**\n   * callback when trigger is entered\n   */\n  onTriggerEnter?: (entity: Entity) => void\n  /**\n   * callback when trigger is exit\n   */\n  onTriggerExit?: (entity: Entity) => void\n  /**\n   * callback when trigger is entered\n   */\n  onCameraEnter?: () => void\n  /**\n   * callback when trigger is exit\n   */\n  onCameraExit?: () => void\n  /**\n   * get if debug is enabled\n   */\n  get debugEnabled(): boolean {\n    return this._debugEnabled\n  }\n\n  private _debugEnabled: boolean = false\n\n  /**\n   *\n   * @param {TriggerBoxShape | TriggerSphereShape} shape shape of the triggering collider area\n   * @param {TriggerData} data An object with additional parameters for the trigger component\n   */\n  constructor(shape: TriggerBoxShape | TriggerSphereShape, data?: TriggerData) {\n    TriggerSystem.createAndAddToEngine()\n    this.shape = shape\n    if (data) {\n      if (data.layer) this.layer = data.layer\n      if (data.triggeredByLayer) this.triggeredByLayer = data.triggeredByLayer\n      if (data.onTriggerEnter) this.onTriggerEnter = data.onTriggerEnter\n      if (data.onTriggerExit) this.onTriggerExit = data.onTriggerExit\n      if (data.onCameraEnter) this.onCameraEnter = data.onCameraEnter\n      if (data.onCameraExit) this.onCameraExit = data.onCameraExit\n      if (data.enableDebug) this._debugEnabled = data.enableDebug\n    }\n  }\n}\n\n/**\n * Define a box-shaped area for using on a TriggerComponent\n * @param {Vector3} [size=2] The scale of the box area. By default 2x2x2\n * @param {Vector3} [position=Vector3.Zero()] The offset from the position of the entity that owns the TriggerComponent\n */\nexport class TriggerBoxShape {\n  size: Vector3\n  position: Vector3\n\n  constructor(size?: Vector3, position?: Vector3) {\n    this.size = size ? size : Vector3.One().scale(2)\n    this.position = position ? position : Vector3.Zero()\n  }\n}\n\n/**\n * Define a sphere-shaped area for using on a TriggerComponent\n * @param {number} [radius=2] The radius of the sphere area. By default 2\n * @param {Vector3} [position=Vector3.Zero()] The offset from the position of the entity that owns the TriggerComponent\n */\nexport class TriggerSphereShape {\n  radius: number\n  position: Vector3\n\n  constructor(radius?: number, position?: Vector3) {\n    this.radius = radius ? radius : 2\n    this.position = position ? position : Vector3.Zero()\n  }\n}\n","/**\n * Maps a value from one range of values to its equivalent, scaled in proportion to another range of values, using maximum and minimum.\n *\n * @param {number} value input number\n * @param {number} min1 Minimum value in the range of the input.\n * @param {number} max1 Maximum value in the range of the input.\n * @param {number} min2 Minimum value in the range of the output.\n * @param {number} max2 Maximum value in the range of the output.\n * @return {number} The resulting mapped value between the new min and max\n *\n */\nexport function map(\n  value: number,\n  min1: number,\n  max1: number,\n  min2: number,\n  max2: number\n) {\n  let range1 = max1 - min1\n  let range2 = max2 - min2\n\n  return ((value - min1) / range1) * range2 + min2\n}\n\n// constrain\n/**\n * Clamps a value so that it doesn't exceed a minimum or a maximum value.\n *\n * @param {number} value input number\n * @param {number} min Minimum output value.\n * @param {number} max Maximum output value.\n * @return {number} The resulting mapped value between the min and max\n *\n */\nexport function clamp(value: number, min: number, max: number) {\n  let result = value\n\n  if (value > max) {\n    result = max\n  } else if (value < min) {\n    result = min\n  }\n  return result\n}\n\n/**\n * Returns the position of an entity that is a child of other entities, relative to the scene instead of relative to the parent. Returns a Vector3.\n *\n * @param {Entity} entity Entity to calculate position\n * @return {Vector3} The Entity's global position in reference to the scene's origin\n *\n */\nexport function getEntityWorldPosition(entity: IEntity): Vector3 {\n  let entityPosition: Vector3 = entity.hasComponent(Transform)\n    ? entity.getComponent(Transform).position.clone()\n    : Vector3.Zero()\n  let parentEntity = entity.getParent()\n\n  if (parentEntity != null) {\n    if (parentEntity.uuid == 'FirstPersonCameraEntityReference') {\n      //log('ATTACHED TO CAMERA')\n      let parentRotation = Camera.instance.rotation.clone()\n      return Camera.instance.position\n        .clone()\n        .add(entityPosition.rotate(parentRotation))\n    } else if (parentEntity.uuid == 'AvatarEntityReference') {\n      //log('ATTACHED TO AVATAR')\n      let camRotation = Camera.instance.rotation\n      let parentRotation = Quaternion.Euler(0, camRotation.eulerAngles.y, 0)\n      //log(Camera.instance.rotation.eulerAngles.y)\n      return Camera.instance.position\n        .clone()\n        .add(entityPosition.rotate(parentRotation))\n        .add(new Vector3(0, -0.875, 0))\n    } else {\n      let parentRotation = parentEntity.hasComponent(Transform)\n        ? parentEntity.getComponent(Transform).rotation\n        : Quaternion.Identity\n      return getEntityWorldPosition(parentEntity).add(\n        entityPosition.rotate(parentRotation)\n      )\n    }\n  }\n  return entityPosition\n}\n\n/**\n * Returns the position of an entity that is a child of other entities, relative to the scene instead of relative to the parent. Returns a Vector3.\n *\n * @param {Entity} entity Entity to calculate position\n * @return {Quaternion} The Entity's global rotation in reference to the scene's origin\n *\n */\nexport function getEntityWorldRotation(entity: IEntity): Quaternion {\n  let entityRotation: Quaternion = entity.hasComponent(Transform)\n    ? entity.getComponent(Transform).rotation.clone()\n    : Quaternion.Zero()\n  let parentEntity = entity.getParent()\n  if (parentEntity != null) {\n    if (parentEntity.uuid == 'FirstPersonCameraEntityReference') {\n      //log('ATTACHED TO CAMERA')\n      let parentRotation = Camera.instance.rotation.clone()\n      return entityRotation.multiply(parentRotation)\n    } else if (parentEntity.uuid == 'AvatarEntityReference') {\n      //log('ATTACHED TO AVATAR')\n      let parentRotation = Quaternion.Euler(\n        0,\n        Camera.instance.rotation.eulerAngles.y,\n        0\n      )\n      return entityRotation.multiply(parentRotation)\n    } else {\n      //   let parentRotation = parentEntity.hasComponent(Transform)\n      //     ? parentEntity.getComponent(Transform).rotation\n      //     : Quaternion.Identity\n      return entityRotation.multiply(getEntityWorldRotation(parentEntity))\n    }\n  }\n  return entityRotation\n}\n","/**\n * Quick function to send HTTP requests to an external address\n *\n * @param {string} url URL to send request to\n * @param {string} method HTTP method (GET by default)\n * @param {*} headers Headers to add to request, as a JSON with key/value pairs per each header\n * @param {*} body Body to add to request, as a JSON object\n * @return {*} The response of the request. If the response is a JSON object, it will be parsed.\n *\n */\nexport async function sendRequest(\n  url: string,\n  method?: string,\n  headers?: any,\n  body?: any\n) {\n  try {\n    let propsObject: requestData = {\n      method: method ? method : 'GET'\n    }\n\n    if (headers) {\n      propsObject.headers = headers\n    }\n\n    if (body) {\n      propsObject.body = JSON.stringify(body)\n    }\n\n    let response = await fetch(url, propsObject)\n    try {\n      let json = await response.json()\n      return json\n    } catch {\n      return response\n    }\n  } catch (error) {\n    log('error fetching from ', url, ' : ', error)\n  }\n}\n\n/**\n * Data to construct an HTTP Request\n *\n * @typedef {Object} requestData\n * @property {string} method The HTTP method (GET, POST, DELETE, PUT, etc)\n * @property {any} headers An object with optional headers to send with the request\n * @property {string} body A stringified JSON to use as a body on a request\n *\n */\nexport type requestData = {\n  method: string\n  headers?: any\n  body?: string\n}\n"],"names":["InterpolationType","this","TransformSystem","_instance","engine","addSystem","component","createAndAddToEngine","_components","push","_b","__values","_componentGroups","getComponentGroup","Transform","dt","i","length","updateComponent","group","entities","forEach","entity","transform","getComponent","comp","update","assignValueToTransform","hasFinished","removeComponent","onFinishCallback","Interpolate","type","t","LINEAR","EASEINQUAD","InterpolateEaseInQuad","EASEOUTQUAD","InterpolateEaseOutQuad","EASEQUAD","InterpolateEaseQuad","ToggleState","start","end","duration","interpolationType","normalizedTime","lerpTime","speed","addComponentType","MoveTransformComponent_1","MoveTransformComponent","Scalar","Clamp","position","Vector3","Lerp","Component","RotateTransformComponent_1","RotateTransformComponent","rotation","Quaternion","Slerp","ScaleTransformComponent_1","ScaleTransformComponent","scale","points","onPointReachedCallback","currentIndex","Error","totalDist","pointsDist","sqDist","Distance","FollowPathComponent_1","FollowPathComponent","numberOfSegments","turnToFaceNext","closedCircle","Curve3","CreateCatmullRomSpline","getPoints","FollowCurvedPathComponent_1","FollowCurvedPathComponent","facingNext","lookAt","rotationVelocity","Identity","finished","KeepRotatingComponent_1","KeepRotatingComponent","multiply","startingState","onValueChangedCallback","On","Off","set","setCallback","ToggleComponent","state","enabled","TimerSystem","_this","record","getEntitiesWithComponent","key","hasOwnProperty","timerComponent","elapsedTime","targetTime","onTargetTimeReached","millisecs","onTimeReachedCallback","Delay_1","Delay","ExpireIn_1","removeEntity","ExpireIn","Interval_1","Interval","addLabel","text","parent","billboard","color","size","textOffset","label","Entity","addComponent","setParent","textShape","TextShape","fontSize","Color3","Black","Billboard","addEntity","ActionsSequenceSystem","TriggerSystem","_cameraTriggerWrapper","CameraTrigger","TriggerBoxShape","_componentGroup","TriggerComponent","Object","shape","setShape","entitiesWithTriggers","shouldWrapTriggerEntity","wrapTriggerEntity","_triggers","wrapper","isDebugging","updateDebugEntity","isInEngine","trigger","wasEnabled","addDebugEntity","onCameraEnter","onCameraExit","checkCollisionAgainstCamera","onTriggerEnter","onTriggerExit","checkCollisionAgainstOtherTriggers","removeDebugEntity","removeTriggerFromSystem","undefined","uuid","TriggerWrapper","activeCollisions","getActiveCollisions","disengageActiveCollision","t1","t2","engageCollision","wereColliding","hasActiveCollision","areColliding","canTriggersCollide","disengageCollision","triggeredByLayer","layer","getShape","areCollidingAABB","getGlobalPosition","TriggerSphereShape","areCollidingSphere","areCollidingAABBSphere","t1GlobalPosition","t1Shape","t2GlobalPosition","t2Shape","getBoxShapeValues","min","x","max","y","z","DistanceSquared","add","radius","box","sphere","dmin","entityGlobalPosition","center","subtract","_entity","_trigger","_uuid","_isDebug","debugEnabled","getEntityWorldPosition","Zero","isAddedToEngine","ret","_collidingWith","other","isPreviewMode","_a","_debugMaterial","Material","alphaTest","_debugEntity","BoxShape","withCollisions","SphereShape","rad","entityPosition","hasComponent","clone","parentEntity","getParent","parentRotation","rotate","_super","_shape","__extends","Camera","instance","data","enableDebug","_debugEnabled","One","sequenceBuilt","startSequence","beginSequenceNode","currentSequenceNode","running","started","currentNode","SubSequenceNode","currentInnerSequence","action","hasFinish","onFinish","next","onStart","SequenceBuilder","SequenceNode","then","condition","ifSeq","IfSequenceNode","seq","getSequence","closed","elseSeq","ElseSequenceNode","whileSeq","WhileSequenceNode","whileNodeStack","splice","BreakWhileSequenceNode","startingInnerSequence","innerSeq","result","ifSequence","breakWhile","whileNode","pos","triggeredFunction","noCollider","keepInProduction","cube","setAll","OnPointerDown","hoverText","button","ActionButton","POINTER","cubeMaterial","albedoColor","value","camRotation","Euler","eulerAngles","getEntityWorldRotation","entityRotation","min1","max1","min2","max2","url","method","headers","body","propsObject","JSON","stringify","fetch","response","json","log","error_1"],"mappings":"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"}