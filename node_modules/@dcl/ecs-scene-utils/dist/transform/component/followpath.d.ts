/// <reference types="dcl" />
import { ITransformComponent } from './itransformcomponent';
/**
 * Component to move an entity down a fixed path in a given amount of time
 */
export declare class FollowPathComponent implements ITransformComponent {
    private points;
    private speed;
    private normalizedTime;
    private currentIndex;
    onFinishCallback?: () => void;
    onPointReachedCallback?: (currentPoint: Vector3, nextPoint: Vector3) => void;
    /**
     * Create a FollowPathComponent instance to add as a component to a Entity
     * @param {Vector3[]} points array of points for the path
     * @param {number} duration duration of the movement through the path
     * @param {() => void} onFinishCallback called when movement ends
     * @param {(currentPoint: Vector3, nextPoint: Vector3) => void} onPointReachedCallback called everytime an entity reaches a point of the path
     */
    constructor(points: Vector3[], duration: number, onFinishCallback?: () => void, onPointReachedCallback?: (currentPoint: Vector3, nextPoint: Vector3) => void);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}
/**
 * Component to move a entity down a fixed path in an amount of time
 */
export declare class FollowCurvedPathComponent implements ITransformComponent {
    private points;
    private speed;
    private normalizedTime;
    private currentIndex;
    private turnToFaceNext;
    private facingNext;
    onFinishCallback?: () => void;
    /**
     * Create a FollowCurvedPathComponent instance to add as a component to a Entity
     * @param {Vector3[]} points array of points that the curve must pass through
     * @param {number} duration duration of the movement through the path
     * @param {number} numberOfSegments how many straight line segments to use to construct the curve
     * @param {boolean} turnToFaceNext if true, rotates for each segment to always look forward
     * @param {boolean} closedCircle if true, traces a circle that starts back at the beginning, keeping the curvature rounded in the seams too
     * @param {() => void} onFinishCallback called when movement ends
     */
    constructor(points: Vector3[], duration: number, numberOfSegments: number, turnToFaceNext?: boolean, closedCircle?: boolean, onFinishCallback?: () => void);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}
